{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\nfrom collections import deque\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# represents the maze \nmaze_grid = [\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '🟥', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '🟩', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],\n    ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛']\n]\n\nglobal current_position\ncurrent_position = (15, 9)\n\nglobal counted_paths\ncounted_paths = 0\n\ndef print_maze():\n    for x in maze_grid:\n        for y in x:\n            brain.print(y)\n        brain.new_line()\n\ndef drive_forward(amount):\n    drivetrain.drive_for(FORWARD, amount, MM)\n\ndef turn_right(amount):\n    drivetrain.turn_for(RIGHT, amount, DEGREES)\n\ndef turn_left(amount):\n    drivetrain.turn_for(LEFT, amount, DEGREES)\n\n# def print_path(path):\n#     brain.print(\"Calculated Path:\")\n#     brain.new_line()\n#     for step in path:\n#         brain.print(step)\n#         brain.new_line()\n\ndef dfs(maze):\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] \n    start, end = None, None\n    \n    # locate start and end points\n    for r in range(rows):\n        for c in range(cols):\n            if maze[r][c] == \"🟥\":\n                start = (r, c)\n            elif maze[r][c] == \"🟩\":\n                end = (r, c)\n    if not start or not end:\n        return []  # no valid start or end\n    stack = [(start, [start])]\n    visited = set()\n    shortest_path = None\n    \n    while stack:\n        (x, y), path = stack.pop()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if (x, y) == end:\n            if shortest_path is None or len(path) < len(shortest_path):\n                shortest_path = path\n            continue\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] != \"⬛\":\n                stack.append(((nx, ny), path + [(nx, ny)]))\n    return shortest_path if shortest_path else []\n\n\n\n\n# update position of robot on map after the robot moves\ndef update_position():\n    global current_position\n    row, col = current_position\n    direction = location.position_angle(DEGREES)\n\n    # make consistent by locking 360 to 0 degrees\n    if direction == 360:\n        direction = 0\n\n    # loop twice to forgive larger map\n    for _ in range(2):\n        # the direction the robot will move \n        if direction == 0:  # north\n            row -= 1\n        elif direction == 90:  # east\n            col += 1\n        elif direction == 180:  # south\n            row += 1\n        elif direction == 270:  # west\n            col -= 1\n\n        # place arrows at current position that isnt at the beginning or end\n        if maze_grid[current_position[0]][current_position[1]] in ('⬛', '🤖'):\n            if direction == 0:  # north\n                maze_grid[current_position[0]][current_position[1]] = '⬆️'\n            elif direction == 90:  # east\n                maze_grid[current_position[0]][current_position[1]] = '➡️'\n            elif direction == 180:  # south\n                maze_grid[current_position[0]][current_position[1]] = '⬇️'\n            elif direction == 270:  # west\n                maze_grid[current_position[0]][current_position[1]] = '⬅️'\n\n        # moves the current position that was determined earlier\n        current_position = (row, col)\n\n        # show current position of robot\n        if maze_grid[row][col] in ('⬛'):\n            maze_grid[row][col] = '🤖'\n    \n    # clear and print after every move\n    brain.clear()\n    print_maze()\n\n# map the maze using right hand rule\ndef map_maze():\n    global green_count\n    green_count = 0\n    monitor_variable(\"green_count\")\n\n    while green_count <= counted_paths:  # stop after reaching the start 3 times\n        # check if there's a wall or an empty space ahead if at end or start position (stops it from exiting the maze and stop it from turning away from start or end if facing outside of maze)\n        if front_distance.get_distance(MM) <= 75 or (not front_distance.found_object() and current_position in [(15, 9), (1, 7)]):\n            drivetrain.stop()\n            turn_left(90)  # turn to avoid wall\n        else:\n            if current_position == (15, 9):  # if at start increase counter\n                green_count += 1  \n            if green_count > counted_paths: # exit loop\n                return\n            # follow right-hand rule\n            drive_forward(250)\n            update_position()\n            turn_right(90)  \n\n# count how many paths extend at start position\ndef count_paths():\n    global counted_paths\n    monitor_variable(\"counted_paths\")\n    # rotate 360 degrees and count where there is a wall detected and is further than 75mm\n    i = 0\n    while i < 4:\n        wait(5, MSEC)\n        turn_right(90)\n        if front_distance.get_distance(MM) >= 75 and front_distance.found_object():\n            counted_paths += 1  # increase amount of paths counted\n        i += 1\n\n\n\n# Add project code in \"main\"\ndef main():\n    pen.move(DOWN)\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    count_paths()\n    map_maze()\n\n    path = dfs(maze_grid)  # run the DFS function\n    path.reverse()  # reverse the list\n\n    brain.print(\"Path to exit:\")\n    for position in path:\n        brain.new_line()\n        brain.print(position)  # print each coordinate on a new line\n\n# VR threads — Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}